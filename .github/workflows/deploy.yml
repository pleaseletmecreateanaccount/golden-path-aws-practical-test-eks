##############################################################################
# Deploy Workflow â€” Infrastructure + Application
#
# Triggers:
#   â€¢ Push to main (auto-deploy)
#   â€¢ Manual (workflow_dispatch) for ad-hoc runs
#
# Required GitHub Secrets:
#   AWS_ROLE_ARN          â€” IAM role ARN to assume (OIDC federation, no keys)
#   DB_PASSWORD           â€” DB password to store in Secrets Manager
#
# Required GitHub Variables:
#   AWS_REGION            â€” ap-southeast-1
#   AWS_ACCOUNT_ID        â€” 825566110381
#   TF_STATE_BUCKET       â€” golden-path-tfstate-825566110381
##############################################################################

name: ðŸš€ Deploy â€” Infrastructure & App

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_terraform:
        description: "Skip Terraform (only redeploy app)"
        type: boolean
        default: false

permissions:
  id-token: write   # Required for OIDC â†’ AWS role assumption (no static keys!)
  contents: read

env:
  AWS_REGION:      ${{ vars.AWS_REGION || 'ap-southeast-1' }}
  AWS_ACCOUNT_ID:  ${{ vars.AWS_ACCOUNT_ID || '825566110381' }}
  TF_DIR:          terraform/environments/production
  CLUSTER_NAME:    golden-path-production
  APP_NAMESPACE:   golden-path
  HELM_RELEASE:    golden-path
  HELM_CHART:      ./helm/golden-path

jobs:
  ##############################################################################
  # Job 1 â€” Terraform Plan (runs on every push for review)
  ##############################################################################
  terraform-plan:
    name: ðŸ“‹ Terraform Plan
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_terraform }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region:     ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.7.5"

      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: terraform init -input=false

      - name: Terraform Validate
        working-directory: ${{ env.TF_DIR }}
        run: terraform validate

      - name: Terraform Plan
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform plan \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -out=tfplan \
            -input=false
        env:
          TF_VAR_aws_region:     ${{ env.AWS_REGION }}
          TF_VAR_aws_account_id: ${{ env.AWS_ACCOUNT_ID }}

      - name: Upload plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: ${{ env.TF_DIR }}/tfplan
          retention-days: 1

  ##############################################################################
  # Job 2 â€” Terraform Apply
  ##############################################################################
  terraform-apply:
    name: ðŸ—ï¸ Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: ${{ !inputs.skip_terraform && github.ref == 'refs/heads/main' }}
    environment: production   # optional GitHub env for manual approval gate

    outputs:
      app_role_arn: ${{ steps.tf-outputs.outputs.app_role_arn }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region:     ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.7.5"
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: terraform init -input=false

      - name: Download plan artifact
        uses: actions/download-artifact@v4
        with:
          name: tfplan
          path: ${{ env.TF_DIR }}

      - name: Terraform Apply
        working-directory: ${{ env.TF_DIR }}
        run: terraform apply -auto-approve -input=false tfplan
        env:
          TF_VAR_aws_region:     ${{ env.AWS_REGION }}
          TF_VAR_aws_account_id: ${{ env.AWS_ACCOUNT_ID }}

      - name: Capture Terraform Outputs
        id: tf-outputs
        working-directory: ${{ env.TF_DIR }}
        run: |
          echo "app_role_arn=$(terraform output -raw app_irsa_role_arn)" >> "$GITHUB_OUTPUT"

  ##############################################################################
  # Job 3 â€” Deploy Application via Helm
  ##############################################################################
  deploy-app:
    name: ðŸŽ¯ Deploy App (Helm)
    runs-on: ubuntu-latest
    needs: [terraform-apply]
    if: |
      always() &&
      (needs.terraform-apply.result == 'success' || inputs.skip_terraform)

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region:     ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ env.CLUSTER_NAME }}

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: "3.14.0"

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.APP_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Wait for External Secrets Operator CRDs
        run: |
          echo "â³ Waiting for ESO CRDs to be established..."
          kubectl wait --for=condition=established \
            crd/clustersecretstores.external-secrets.io \
            --timeout=120s

      - name: Apply ClusterSecretStore
        run: |
          kubectl apply -f k8s/cluster-secret-store.yaml

      - name: Get App IRSA Role ARN
        id: get-role
        run: |
          if [ -n "${{ needs.terraform-apply.outputs.app_role_arn }}" ]; then
            echo "role_arn=${{ needs.terraform-apply.outputs.app_role_arn }}" >> "$GITHUB_OUTPUT"
          else
            # Fallback: fetch from Terraform state directly
            cd ${{ env.TF_DIR }}
            terraform init -input=false -reconfigure
            echo "role_arn=$(terraform output -raw app_irsa_role_arn)" >> "$GITHUB_OUTPUT"
          fi

      - name: Helm Upgrade / Install
        run: |
          helm upgrade --install ${{ env.HELM_RELEASE }} ${{ env.HELM_CHART }} \
            --namespace ${{ env.APP_NAMESPACE }} \
            --create-namespace \
            --atomic \
            --timeout 5m \
            --set "serviceAccount.annotations.eks\\.amazonaws\\.com/role-arn=${{ steps.get-role.outputs.role_arn }}" \
            --set "image.tag=stable-alpine" \
            --wait

      - name: Verify rollout
        run: |
          kubectl rollout status deployment/${{ env.HELM_RELEASE }}-golden-path \
            -n ${{ env.APP_NAMESPACE }} \
            --timeout=3m

      - name: Print ALB hostname
        run: |
          echo "â³ Waiting for ALB address..."
          for i in $(seq 1 20); do
            ADDRESS=$(kubectl get ingress ${{ env.HELM_RELEASE }}-golden-path \
              -n ${{ env.APP_NAMESPACE }} \
              -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            if [ -n "$ADDRESS" ]; then
              echo ""
              echo "âœ… Application is live at: http://$ADDRESS"
              break
            fi
            echo "Attempt $i/20 â€” waiting 15s..."
            sleep 15
          done
